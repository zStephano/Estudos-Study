## CREATE DATABASE

Para criar um banco de dados no SQL Server, voc√™ pode usar a instru√ß√£o `CREATE DATABASE`. Essa instru√ß√£o cria um novo banco de dados e os arquivos associados a ele. Aqui est√° a sintaxe b√°sica:

```sql
CREATE DATABASE nome_do_banco_de_dados;
```

Substitua `nome_do_banco_de_dados` pelo nome que voc√™ deseja dar ao seu banco de dados. Lembre-se de que espa√ßos em branco n√£o s√£o permitidos no nome do banco de dados; voc√™ pode usar sublinhados (_) em vez disso. Por exemplo, para criar um banco de dados chamado "GeeksForGeeks", voc√™ pode usar:

```sql
CREATE DATABASE GeeksForGeeks;
```

Depois de executar essa instru√ß√£o, o novo banco de dados ser√° criado e estar√° pronto para uso.

------------------------------------------------------

## CREATE TABLE

Para criar uma nova tabela no SQL Server, voc√™ pode usar a instru√ß√£o `CREATE TABLE`. Essa instru√ß√£o permite especificar o nome da tabela, bem como as colunas e os tipos de dados que ser√£o armazenados. Aqui est√° a sintaxe b√°sica:

```sql
CREATE TABLE nome_da_tabela (
    coluna1 tipo_de_dados,
    coluna2 tipo_de_dados,
    coluna3 tipo_de_dados,
    ...
);
```

Substitua `nome_da_tabela` pelo nome que voc√™ deseja dar √† sua tabela. As colunas s√£o especificadas com seus respectivos nomes e tipos de dados. Por exemplo, para criar uma tabela chamada "Pessoas" com cinco colunas (PersonID, LastName, FirstName, Address e City), voc√™ pode usar:

```sql
CREATE TABLE Pessoas (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
);
```

A coluna `PersonID` √© do tipo `int` e armazenar√° valores inteiros. As colunas `LastName`, `FirstName`, `Address` e `City` s√£o do tipo `varchar` e armazenar√£o caracteres, com um comprimento m√°ximo de 255 caracteres.

A tabela "Pessoas" vazia ficar√° assim:

```
PersonID | LastName | FirstName | Address | City
-------------------------------------------------
```

Lembre-se de que voc√™ pode preencher a tabela "Pessoas" com dados usando a instru√ß√£o `INSERT INTO`.

------------------------------------------------------

## ALTER/DROP TABLE

Vamos explorar como alterar e excluir tabelas e colunas no **SQL Server**. Para isso, utilizaremos dois comandos principais: **ALTER TABLE** e **DROP TABLE**.

1. **ALTER TABLE**:
   - Com o comando `ALTER TABLE`, √© poss√≠vel modificar a estrutura de uma tabela ap√≥s sua cria√ß√£o. Vejamos as a√ß√µes poss√≠veis:
     - **Adicionar uma coluna √† tabela**:
       ```sql
       ALTER TABLE nome_tabela ADD nome_coluna tipo_dados;
       ```
     - **Excluir uma coluna de uma tabela**:
       ```sql
       ALTER TABLE nome_tabela DROP COLUMN nome_coluna;
       ```
     - **Alterar o tipo de dados de uma coluna**:
       ```sql
       ALTER TABLE nome_tabela ALTER COLUMN nome_coluna tipo_dados;
       ```
     - **Adicionar uma constraint do tipo NOT NULL a uma coluna**:
       ```sql
       ALTER TABLE nome_tabela ALTER COLUMN nome_coluna tipo_dados NOT NULL;
       ```
     - **Adicionar uma constraint de chave prim√°ria a uma coluna**:
       ```sql
       ALTER TABLE nome_tabela ADD CONSTRAINT nome_constraint PRIMARY KEY (coluna1, coluna2, ...);
       ```
     - **Excluir uma constraint de uma tabela**:
       ```sql
       ALTER TABLE nome_tabela DROP CONSTRAINT nome_constraint;
       ```
   - Exemplos:
     - Excluir a coluna `ID_Autor` da tabela `tbl_livros`:
       ```sql
       ALTER TABLE tbl_livros DROP COLUMN ID_Autor;
       ```
     - Adicionar a coluna `ID_Autor` √† tabela `tbl_livros` como chave estrangeira da coluna `ID_Autor` da tabela `tbl_autores`:
       ```sql
       ALTER TABLE tbl_livros ADD ID_Autor SMALLINT NOT NULL CONSTRAINT fk_ID_Autor FOREIGN KEY (ID_Autor) REFERENCES tbl_autores (ID_autor);
       ```
     - Alterar o tipo de dados da coluna `ID_Autor` para `SMALLINT`:
       ```sql
       ALTER TABLE tbl_livros ALTER COLUMN ID_Autor SMALLINT;
       ```
     - Adicionar a constraint `PRIMARY KEY` √† coluna `ID_Cliente` (j√° existente) da tabela `Clientes`:
       ```sql
       ALTER TABLE Clientes ADD CONSTRAINT pk_id_cliente PRIMARY KEY (ID_Cliente);
       ```

2. **DROP TABLE**:
   - O comando `DROP TABLE` √© usado para excluir uma tabela do banco de dados, incluindo todos os seus dados.
   - Sintaxe:
     ```sql
     DROP TABLE nome_tabela;
     ```
   - Exemplo:
     ```sql
     DROP TABLE Clientes;
     ```

**Exerc√≠cio para Fixa√ß√£o**:
1. Crie uma nova tabela chamada `tbl_generos` no banco de dados `db_Biblioteca` para armazenar g√™neros de livros.
2. Adicione uma coluna √† tabela de livros para relacion√°-la com a tabela de g√™neros.
3. Insira um novo registro de livro no banco, considerando editoras, autores e g√™neros necess√°rios. üìö

------------------------------------------------------

## CONSTRAINTS

Essas restri√ß√µes s√£o essenciais para garantir a precis√£o e confiabilidade dos dados em uma tabela. Quando aplicadas corretamente, elas evitam erros e mant√™m a integridade do banco de dados. Vamos l√°:

1. **O que s√£o Constraints?**
   - As **constraints** s√£o regras aplicadas a colunas de uma tabela. Elas definem caracter√≠sticas espec√≠ficas para essas colunas.
   - Alguns exemplos de **constraints** incluem:
     - **NOT NULL**: Impede que uma coluna aceite valores nulos (ou seja, vazios).
     - **UNIQUE**: Garante que os valores em uma coluna sejam exclusivos (sem duplicatas).
     - **PRIMARY KEY**: Define uma coluna como chave prim√°ria, garantindo unicidade e indexa√ß√£o.
     - **FOREIGN KEY**: Relaciona uma coluna com outra tabela, mantendo a integridade referencial.
     - **CHECK**: Permite definir condi√ß√µes espec√≠ficas para os valores de uma coluna.
     - **DEFAULT**: Define um valor padr√£o para uma coluna, caso nenhum valor seja especificado.

2. **Por que usar Constraints?**
   - Imagine uma coluna que armazena placas de carros. Sem **constraints**, qualquer valor seria aceito, inclusive valores inv√°lidos.
   - As **constraints** evitam erros humanos, transfer√™ncias incorretas e problemas causados por bugs ou v√≠rus.
   - Elas tornam o banco de dados mais confi√°vel e robusto.

3. **Tipos de Constraints**:
   - **NOT NULL**: Impede valores nulos.
   - **UNIQUE**: Garante valores exclusivos.
   - **PRIMARY KEY**: Define uma chave prim√°ria.
   - **FOREIGN KEY**: Mant√©m integridade referencial.
   - **CHECK**: Permite condi√ß√µes personalizadas.
   - **DEFAULT**: Define valores padr√£o.

Em resumo, as **constraints** s√£o como regras que moldam o comportamento das colunas em uma tabela, garantindo dados corretos e consistentes.

------------------------------------------------------

## PRIMARY KEY

A chave prim√°ria √© uma restri√ß√£o que identifica exclusivamente cada registro em uma tabela. Ela garante a integridade dos dados e evita duplicatas. Aqui est√£o os pontos-chave:

1. **O que √© uma Chave Prim√°ria?**
   - A **chave prim√°ria** √© uma coluna (ou combina√ß√£o de colunas) que identifica de forma √∫nica cada linha em uma tabela.
   - Ela deve conter valores **√∫nicos** e n√£o pode conter valores **nulos**.
   - Uma tabela pode ter **apenas uma chave prim√°ria**.

2. **Exemplos de Sintaxe:**
   - Para criar uma chave prim√°ria ao criar uma tabela:
     ```sql
     CREATE TABLE Pessoas (
         ID int NOT NULL PRIMARY KEY,
         LastName varchar(255) NOT NULL,
         FirstName varchar(255),
         Age int
     );
     ```
   - Para adicionar uma chave prim√°ria a uma tabela existente:
     ```sql
     ALTER TABLE Pessoas ADD CONSTRAINT PK_Person PRIMARY KEY (ID);
     ```

3. **Benef√≠cios da Chave Prim√°ria:**
   - Garante unicidade dos registros.
   - Facilita a indexa√ß√£o e busca eficiente.
   - Mant√©m a integridade dos dados.

------------------------------------------------------

## COMPOSITE KEY

Uma chave prim√°ria composta √© aquela que consiste em duas ou mais colunas em uma tabela. Tamb√©m √© conhecida como chave prim√°ria composta. Vamos entender melhor:

1. **O que √© uma Chave Prim√°ria Composta?**
   - Uma **chave prim√°ria composta** √© uma combina√ß√£o de colunas que identifica exclusivamente cada linha em uma tabela.
   - Ela deve conter valores **√∫nicos** e n√£o pode conter valores **nulos**.
   - Uma tabela pode ter **apenas uma chave prim√°ria**, mas essa chave pode ser composta por v√°rias colunas.

2. **Exemplo de Sintaxe:**
   - Para criar uma chave prim√°ria composta ao criar uma tabela:
     ```sql
     CREATE TABLE Votacao (
         ID_Pergunta NUMERIC,
         ID_Membro NUMERIC,
         PRIMARY KEY (ID_Pergunta, ID_Membro)
     );
     ```
   - A combina√ß√£o `(ID_Pergunta, ID_Membro)` deve ser √∫nica para a tabela, e nenhum dos valores pode ser nulo.
   - Se voc√™ fizer uma consulta como esta:
     ```sql
     SELECT * FROM Votacao WHERE ID_Pergunta = 7;
     ```
     Ela usar√° o √≠ndice da chave prim√°ria.
   - No entanto, se fizer isso:
     ```sql
     SELECT * FROM Votacao WHERE ID_Membro = 7;
     ```
     N√£o usar√° o √≠ndice da chave prim√°ria, pois √© necess√°rio usar todas as colunas da esquerda do √≠ndice composto.
   - Escolha entre `(ID_Pergunta, ID_Membro)` e `(ID_Membro, ID_Pergunta)` com base na forma como usar√° a tabela. Se necess√°rio, adicione um √≠ndice √∫nico na outra ordem:
     ```sql
     CREATE UNIQUE INDEX idx1 ON Votacao (ID_Membro, ID_Pergunta);
     ```

3. **Benef√≠cios da Chave Prim√°ria Composta:**
   - Garante a unicidade dos registros.
   - Facilita a indexa√ß√£o e a busca eficiente.
   - Mant√©m a integridade dos dados.

------------------------------------------------------

## INDEX / √çNDICES

Essas estruturas s√£o fundamentais para otimizar o desempenho das consultas e melhorar a velocidade de recupera√ß√£o dos dados. Vou explicar os principais pontos:

1. **Como o SQL Server Armazena e Acessa Dados:**
   - Os registros s√£o armazenados em **p√°ginas de dados**, que comp√µem uma **pilha**. Cada p√°gina tem at√© 8 KB e cont√©m um cabe√ßalho, links para outras p√°ginas e dados.
   - N√£o h√° ordena√ß√£o sequencial nas p√°ginas de dados; elas formam uma pilha.
   - Quando uma p√°gina est√° quase cheia, ela √© dividida e estabelece links entre as partes.

2. **Como os Dados S√£o Localizados:**
   - Existem dois m√©todos:
     - **Exame de Tabela**: Percorre todas as p√°ginas de dados da tabela, examinando os registros.
     - **Usando √çndices**: Navega na estrutura da √°rvore do √≠ndice para localizar registros espec√≠ficos.

3. **√çndices no SQL Server:**
   - Existem dois tipos principais:
     - **√çndice Clusterizado**: Define a ordem f√≠sica dos dados na tabela. A pr√≥pria tabela √© reorganizada com base no √≠ndice.
     - **√çndice N√£o Clusterizado**: Cria uma estrutura separada para os dados do √≠ndice, apontando para as p√°ginas de dados da tabela.
   - Os √≠ndices melhoram a efici√™ncia das consultas e reduzem gargalos.

------------------------------------------------------

## IDENTITY

Essa propriedade √© usada para criar uma coluna de identidade em uma tabela, gerando valores exclusivos para cada linha. Aqui est√£o os principais pontos:

1. **Sintaxe da Propriedade IDENTITY:**
   - A sintaxe b√°sica √© a seguinte:
     ```sql
     IDENTITY [(seed, increment)]
     ```
   - O **seed** √© o valor usado para a primeira linha carregada na tabela.
   - O **increment** √© o valor incremental adicionado ao valor de identidade da linha anterior que foi carregada.
   - Se nenhum valor for especificado, o padr√£o ser√° (1,1).

2. **Benef√≠cios da Propriedade IDENTITY:**
   - Garante valores exclusivos para cada linha.
   - Facilita a cria√ß√£o de chaves prim√°rias.
   - Melhora o desempenho das consultas.

3. **Observa√ß√µes Importantes:**
   - A propriedade IDENTITY n√£o garante exclusividade do valor; use restri√ß√µes PRIMARY KEY ou UNIQUE para isso.
   - Valores consecutivos n√£o s√£o garantidos em transa√ß√µes simult√¢neas.
   - Ap√≥s reinicializa√ß√µes do servidor, pode haver intervalos nos valores de identidade.

------------------------------------------------------

## INSERT

O comando **INSERT** √© usado para inserir novos registros em uma tabela no **SQL**. Vou explicar como us√°-lo:

1. **Sintaxe B√°sica:**
   - Existem duas maneiras de escrever o comando **INSERT INTO**:
     1. Especificando os nomes das colunas e os valores a serem inseridos:
        ```sql
        INSERT INTO nome_da_tabela (coluna1, coluna2, coluna3, ...) VALUES (valor1, valor2, valor3, ...);
        ```
     2. Se voc√™ estiver adicionando valores para todas as colunas da tabela, n√£o precisa especificar os nomes das colunas:
        ```sql
        INSERT INTO nome_da_tabela VALUES (valor1, valor2, valor3, ...);
        ```

2. **Exemplo:**
   - Suponha que temos a tabela "Clientes" com as colunas "CustomerName", "ContactName", "Address", "City", "PostalCode" e "Country".
   - Para inserir um novo cliente chamado "Cardinal" com informa√ß√µes, podemos usar:
     ```sql
     INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)
     VALUES ('Cardinal', 'Tom B. Erichsen', 'Skagen 21', 'Stavanger', '4006', 'Norway');
     ```

3. **Observa√ß√µes:**
   - A coluna "CustomerID" n√£o foi especificada porque √© um campo de incremento autom√°tico.
   - Voc√™ tamb√©m pode inserir dados apenas em colunas espec√≠ficas.
   - √â poss√≠vel inserir v√°rias linhas em uma √∫nica instru√ß√£o.

------------------------------------------------------

## SELECT

O comando **SELECT** √© um dos mais importantes da linguagem SQL e permite recuperar dados de um objeto do banco de dados, como uma tabela, view ou, em alguns casos, uma stored procedure. Vamos explorar os principais aspectos:

1. **Sintaxe B√°sica:**
   - A estrutura b√°sica do comando SELECT √©:
     ```sql
     SELECT <lista_de_campos> FROM <nome_da_tabela>;
     ```
   - Por exemplo:
     ```sql
     SELECT CODIGO, NOME FROM CLIENTES;
     ```
   - O caractere `*` representa todos os campos, mas seu uso n√£o √© recomendado, pois pode afetar o desempenho.

2. **Filtrando Dados com a Cl√°usula WHERE:**
   - A cl√°usula `WHERE` permite aplicar condi√ß√µes de filtragem aos registros.
   - Exemplos:
     - Selecionar clientes com c√≥digo igual a 10:
       ```sql
       SELECT CODIGO, NOME FROM CLIENTES WHERE CODIGO = 10;
       ```
     - Selecionar clientes do Rio de Janeiro ou inativos em S√£o Paulo:
       ```sql
       SELECT CODIGO, NOME FROM CLIENTES WHERE UF = 'RJ' OR (UF = 'SP' AND ATIVO = 'N');
       ```
     - Buscar clientes cujos nomes iniciam com "Maria":
       ```sql
       SELECT CODIGO, NOME FROM CLIENTES WHERE NOME LIKE 'MARIA%';
       ```

3. **Ordena√ß√£o de Resultados:**
   - Use a cl√°usula `ORDER BY` para ordenar os resultados:
     ```sql
     SELECT CODIGO, NOME FROM CLIENTES ORDER BY NOME;
     ```

4. **Fun√ß√µes de Agrupamento e Agrupamento com HAVING:**
   - Para c√°lculos agregados (soma, m√©dia, contagem etc.), use fun√ß√µes como `SUM`, `AVG`, `COUNT`, etc.
   - Exemplo:
     ```sql
     SELECT UF, COUNT(*) AS TotalClientes FROM CLIENTES GROUP BY UF HAVING COUNT(*) > 10;
     ```

O comando SELECT √© poderoso e vers√°til.

------------------------------------------------------

## QUERIES

As queries (consultas) s√£o essenciais para recuperar, filtrar e manipular dados em bancos de dados relacionais. Aqui est√£o os principais conceitos:

1. **Estrutura B√°sica de Queries SQL:**
   - Uma query SQL envolve o uso de cl√°usulas como `SELECT`, `FROM`, `WHERE`, `GROUP BY` e `ORDER BY`.
   - A cl√°usula `SELECT` especifica as colunas que voc√™ deseja recuperar.
   - A cl√°usula `FROM` indica a tabela da qual voc√™ est√° consultando os dados.
   - A cl√°usula `WHERE` permite aplicar filtros aos registros.
   - A cl√°usula `GROUP BY` √© usada para agrupar resultados com base em uma ou mais colunas.
   - A cl√°usula `ORDER BY` ordena os resultados.

2. **Exemplo de Query:**
   - Suponha que temos uma tabela chamada "Clientes" com colunas como "Nome", "Cidade" e "Idade".
   - Para recuperar os nomes dos clientes de S√£o Paulo com idade acima de 30 anos, podemos usar:
     ```sql
     SELECT Nome FROM Clientes WHERE Cidade = 'S√£o Paulo' AND Idade > 30;
     ```

3. **Dicas Importantes:**
   - Use aliases para renomear colunas ou tabelas na query.
   - Evite usar `SELECT *` para melhorar a performance e evitar trazer colunas desnecess√°rias.
   - Pratique consultas em bancos de dados de exemplo para aprimorar suas habilidades.

------------------------------------------------------

## ORDER BY

A cl√°usula **ORDER BY** √© usada para obter registros ordenados por uma ou mais colunas em ordem ascendente ou descendente. Ela deve vir ap√≥s as cl√°usulas **WHERE**, **GROUP BY** e **HAVING**, se presentes na consulta. Vejamos os principais pontos:

1. **Sintaxe B√°sica:**
   - A estrutura b√°sica da cl√°usula **SELECT** com **ORDER BY** √©:
     ```sql
     SELECT <lista_de_campos> FROM <nome_da_tabela> ORDER BY <coluna1> [ASC | DESC], <coluna2> [ASC | DESC], ...;
     ```
   - Por exemplo:
     ```sql
     SELECT CODIGO, NOME FROM CLIENTES ORDER BY NOME;
     ```
   - Use **ASC** para ordenar em ordem crescente e **DESC** para ordem decrescente.

2. **Exemplo:**
   - Suponha que temos uma tabela "Clientes" com colunas como "Nome", "Cidade" e "Idade".
   - Para recuperar os nomes dos clientes de S√£o Paulo com idade acima de 30 anos, podemos usar:
     ```sql
     SELECT Nome FROM Clientes WHERE Cidade = 'S√£o Paulo' AND Idade > 30 ORDER BY Nome;
     ```

3. **Dicas Importantes:**
   - Evite usar `SELECT *` para melhorar o desempenho e evitar trazer colunas desnecess√°rias.
   - A ordem das colunas na cl√°usula **ORDER BY** define a organiza√ß√£o do conjunto de resultados classificado.

------------------------------------------------------

## UPDATE

O comando **UPDATE** √© usado para modificar registros existentes em uma tabela no **SQL**. Vou explicar como us√°-lo:

1. **Sintaxe B√°sica:**
   - A estrutura b√°sica do comando **UPDATE** √©:
     ```sql
     UPDATE nome_da_tabela SET coluna1 = valor1, coluna2 = valor2, ... WHERE condi√ß√£o;
     ```
   - Por exemplo, para atualizar o contato e a cidade do primeiro cliente (CustomerID = 1):
     ```sql
     UPDATE Customers SET ContactName = 'Alfred Schmidt', City = 'Frankfurt' WHERE CustomerID = 1;
     ```

2. **Atualiza√ß√£o de M√∫ltiplos Registros:**
   - A cl√°usula `WHERE` determina quantos registros ser√£o atualizados.
   - O seguinte exemplo atualiza o campo `ContactName` para "Juan" em todos os registros onde o pa√≠s √© "Mexico":
     ```sql
     UPDATE Customers SET ContactName = 'Juan' WHERE Country = 'Mexico';
     ```

3. **Cuidado!**
   - Se voc√™ omitir a cl√°usula `WHERE`, **todos** os registros na tabela ser√£o atualizados!
   - Use com aten√ß√£o para evitar altera√ß√µes indesejadas.

------------------------------------------------------

## DELETE

O comando **DELETE** permite que uma ou mais linhas sejam exclu√≠das de uma tabela no banco de dados. Vamos explorar os principais aspectos:

1. **Sintaxe B√°sica:**
   - A estrutura b√°sica do comando **DELETE** √©:
     ```sql
     DELETE FROM nome_da_tabela WHERE condi√ß√£o_de_busca;
     ```
   - Por exemplo, para remover o produto com ID igual a 3 da tabela "produtos":
     ```sql
     DELETE FROM produtos WHERE id = 3;
     ```

2. **Exemplo:**
   - Suponha que temos uma tabela "Clientes" com colunas como "Nome", "Cidade" e "Idade".
   - Para excluir um cliente espec√≠fico (por exemplo, com ID igual a 8), podemos usar:
     ```sql
     DELETE FROM Clientes WHERE ID = 8;
     ```

3. **Cuidados:**
   - A cl√°usula `WHERE` √© essencial para identificar qual registro ser√° removido.
   - Tenha cuidado ao usar o comando DELETE, pois ele afeta permanentemente os dados.

------------------------------------------------------

## MIN, MAX & COUNT

1. **MIN (Valor M√≠nimo)**:
   - A fun√ß√£o **MIN** retorna o menor valor de uma coluna especificada.
   - Por exemplo, para encontrar o menor pre√ßo entre todos os produtos, voc√™ pode usar:
     ```sql
     SELECT MIN(preco) AS MenorPreco FROM produtos;
     ```

2. **MAX (Valor M√°ximo)**:
   - A fun√ß√£o **MAX** retorna o maior valor de uma coluna especificada.
   - Para encontrar o maior pre√ßo entre todos os produtos, use:
     ```sql
     SELECT MAX(preco) AS MaiorPreco FROM produtos;
     ```

3. **COUNT (N√∫mero de Linhas)**:
   - A fun√ß√£o **COUNT** calcula o n√∫mero total de linhas em um conjunto de resultados.
   - Por exemplo, para contar o n√∫mero total de clientes, voc√™ pode fazer:
     ```sql
     SELECT COUNT(*) AS TotalClientes FROM clientes;
     ```

Lembre-se:
- Essas fun√ß√µes de agrega√ß√£o podem ser usadas em combina√ß√£o com outras cl√°usulas (por exemplo, **WHERE**).
- Tenha cuidado com as opera√ß√µes de **DELETE** e **UPDATE**, especialmente ao usar fun√ß√µes de agrega√ß√£o sem o devido filtro.

------------------------------------------------------

## LIKE

A cl√°usula **LIKE** √© usada para buscar registros que correspondam a um padr√£o espec√≠fico em uma coluna. Ela √© frequentemente usada com dois curingas:

1. O sinal de porcentagem (%) representa zero, um ou v√°rios caracteres.
2. O sublinhado (_) representa um √∫nico caractere.

Aqui est√£o alguns exemplos:

- Para selecionar todos os clientes cujos nomes come√ßam com a letra "a":
  ```sql
  SELECT * FROM Customers WHERE CustomerName LIKE 'a%';
  ```

- Para encontrar clientes de uma cidade que come√ßa com "L", seguido por um caractere curinga, depois "nd" e, finalmente, mais dois caracteres curinga:
  ```sql
  SELECT * FROM Customers WHERE city LIKE 'L_nd__';
  ```

- Para retornar clientes cujos nomes cont√™m a letra "L":
  ```sql
  SELECT * FROM Customers WHERE city LIKE '%L%';
  ```

- Para obter clientes cujos nomes terminam com "a":
  ```sql
  SELECT * FROM Customers WHERE CustomerName LIKE '%a';
  ```

- Voc√™ tamb√©m pode combinar "come√ßa com" e "termina com":
  ```sql
  SELECT * FROM Customers WHERE CustomerName LIKE 'b%s';
  ```

Lembre-se de usar a cl√°usula **WHERE** para filtrar os resultados adequadamente.

------------------------------------------------------

## IN, BETWEEN

# Cl√°usula IN
A cl√°usula **IN** √© uma ferramenta poderosa para filtrar dados com base em uma lista de valores espec√≠ficos. Ela permite comparar uma coluna com diversos valores de maneira eficiente e concisa. Vejamos os detalhes:

### Sintaxe B√°sica
A sintaxe b√°sica da cl√°usula **IN** √© simples. Ela √© usada em conjunto com a instru√ß√£o **SELECT** da seguinte maneira:
```sql
SELECT coluna FROM tabela WHERE coluna IN (valor1, valor2, valor3, ...);
```

### Exemplo Pr√°tico
Suponha que temos uma tabela de produtos e queremos recuperar todos os produtos que pertencem √† categoria "Eletr√¥nicos" ou "Roupas", al√©m dos produtos em promo√ß√£o. A consulta poderia ser assim:
```sql
SELECT nome_produto FROM produtos WHERE categoria IN ('Eletr√¥nicos', 'Roupas') OR em_promocao = 1;
```

A cl√°usula **IN** pode ser utilizada com diferentes tipos de dados, como n√∫meros, strings e datas. Al√©m disso, √© poss√≠vel combinar a cl√°usula **IN** com outras condi√ß√µes usando operadores l√≥gicos (AND, OR) para criar consultas mais complexas e precisas.

# Cl√°usula BETWEEN
A cl√°usula **BETWEEN** √© usada para selecionar dados em um intervalo num√©rico ou de datas. Ela √© especialmente √∫til para consultas que envolvem valores contidos em um intervalo espec√≠fico.

### Sintaxe B√°sica
A sintaxe b√°sica da cl√°usula **BETWEEN** √© a seguinte:
```sql
SELECT coluna FROM tabela WHERE coluna BETWEEN valor_inicial AND valor_final;
```

### Exemplo Pr√°tico
Suponha que temos uma tabela de vendas e queremos recuperar todas as vendas realizadas entre as datas de 1¬∫ de janeiro de 2024 e 31 de mar√ßo de 2024. A consulta poderia ser assim:
```sql
SELECT * FROM vendas WHERE data_venda BETWEEN '2024-01-01' AND '2024-03-31';
```

A cl√°usula **BETWEEN** tamb√©m pode ser aplicada a outros tipos de dados, como valores num√©ricos.

Em resumo, tanto a cl√°usula **IN** quanto a cl√°usula **BETWEEN** s√£o ferramentas essenciais para filtrar dados de maneira precisa e eficiente em consultas SQL.

------------------------------------------------------

## ALIAS

A cl√°usula **ALIAS** √© usada para atribuir um nome tempor√°rio a uma tabela ou a uma coluna em uma consulta SQL. Ela √© especialmente √∫til para melhorar a legibilidade das consultas e para evitar ambiguidades quando h√° jun√ß√µes de tabelas ou c√°lculos envolvidos.

### Uso de ALIAS para Colunas
- Voc√™ pode atribuir um alias a uma coluna para tornar o resultado mais descritivo.
- Por exemplo, suponha que temos uma tabela de funcion√°rios com colunas "Nome", "Sal√°rio" e "Data de Contrata√ß√£o". Para obter uma lista de funcion√°rios com seus sal√°rios mensais, podemos usar:
  ```sql
  SELECT Nome, Salario AS SalarioMensal FROM Funcionarios;
  ```
  Nesse caso, o alias "SalarioMensal" torna o resultado mais claro.

### Uso de ALIAS para Tabelas
- Quando voc√™ faz jun√ß√µes (joins) entre v√°rias tabelas, pode usar aliases para diferenciar as tabelas.
- Por exemplo, se tivermos uma tabela de pedidos ("Pedidos") e uma tabela de clientes ("Clientes"), podemos fazer um join assim:
  ```sql
  SELECT p.NumeroPedido, c.Nome AS NomeCliente
  FROM Pedidos p
  INNER JOIN Clientes c ON p.ClienteID = c.ClienteID;
  ```
  Nesse caso, os aliases "p" e "c" representam as tabelas "Pedidos" e "Clientes", respectivamente.

### Dicas Importantes
- Use aliases de forma consistente e significativa para facilitar a leitura das consultas.
- Lembre-se de que os aliases s√£o tempor√°rios e se aplicam apenas √† consulta atual.

------------------------------------------------------

## JOINS

Os joins em SQL s√£o usados para combinar registros de duas ou mais tabelas em um banco de dados. Existem v√°rios tipos de joins, cada um com um prop√≥sito espec√≠fico. Aqui est√£o os principais tipos de joins:

### 1. **INNER JOIN**
Combina registros que t√™m valores correspondentes em ambas as tabelas.
```sql
SELECT a.coluna1, b.coluna2
FROM tabelaA a
INNER JOIN tabelaB b ON a.coluna_comum = b.coluna_comum;
```

### 2. **LEFT JOIN (ou LEFT OUTER JOIN)**
Retorna todos os registros da tabela da esquerda (tabelaA), e os registros correspondentes da tabela da direita (tabelaB). Se n√£o houver correspond√™ncia, os resultados conter√£o valores NULL para as colunas da tabela da direita.
```sql
SELECT a.coluna1, b.coluna2
FROM tabelaA a
LEFT JOIN tabelaB b ON a.coluna_comum = b.coluna_comum;
```

### 3. **RIGHT JOIN (ou RIGHT OUTER JOIN)**
Retorna todos os registros da tabela da direita (tabelaB), e os registros correspondentes da tabela da esquerda (tabelaA). Se n√£o houver correspond√™ncia, os resultados conter√£o valores NULL para as colunas da tabela da esquerda.
```sql
SELECT a.coluna1, b.coluna2
FROM tabelaA a
RIGHT JOIN tabelaB b ON a.coluna_comum = b.coluna_comum;
```

### 4. **FULL JOIN (ou FULL OUTER JOIN)**
Retorna todos os registros quando h√° uma correspond√™ncia em tabelaA ou tabelaB. Registros sem correspond√™ncia em uma das tabelas ter√£o valores NULL nas colunas dessa tabela.
```sql
SELECT a.coluna1, b.coluna2
FROM tabelaA a
FULL OUTER JOIN tabelaB b ON a.coluna_comum = b.coluna_comum;
```

### 5. **CROSS JOIN**
Retorna o produto cartesiano de duas tabelas. Cada registro da tabelaA √© combinado com todos os registros da tabelaB.
```sql
SELECT a.coluna1, b.coluna2
FROM tabelaA a
CROSS JOIN tabelaB b;
```

### 6. **SELF JOIN**
Um join de uma tabela consigo mesma. √â √∫til para opera√ß√µes que comparam registros na mesma tabela.
```sql
SELECT a.coluna1, b.coluna2
FROM tabelaA a
INNER JOIN tabelaA b ON a.coluna_comum = b.coluna_comum;
```

### Exemplos Pr√°ticos
Suponha que temos duas tabelas:

**Employees**
| EmployeeID | Name      | DepartmentID |
|------------|-----------|--------------|
| 1          | John      | 1            |
| 2          | Jane      | 2            |
| 3          | Sam       | NULL         |

**Departments**
| DepartmentID | DepartmentName |
|--------------|----------------|
| 1            | HR             |
| 2            | IT             |
| 3            | Marketing      |

#### INNER JOIN
```sql
SELECT e.Name, d.DepartmentName
FROM Employees e
INNER JOIN Departments d ON e.DepartmentID = d.DepartmentID;
```
**Resultado:**
| Name | DepartmentName |
|------|----------------|
| John | HR             |
| Jane | IT             |

#### LEFT JOIN
```sql
SELECT e.Name, d.DepartmentName
FROM Employees e
LEFT JOIN Departments d ON e.DepartmentID = d.DepartmentID;
```
**Resultado:**
| Name | DepartmentName |
|------|----------------|
| John | HR             |
| Jane | IT             |
| Sam  | NULL           |

#### RIGHT JOIN
```sql
SELECT e.Name, d.DepartmentName
FROM Employees e
RIGHT JOIN Departments d ON e.DepartmentID = d.DepartmentID;
```
**Resultado:**
| Name | DepartmentName |
|------|----------------|
| John | HR             |
| Jane | IT             |
| NULL | Marketing      |

#### FULL JOIN
```sql
SELECT e.Name, d.DepartmentName
FROM Employees e
FULL OUTER JOIN Departments d ON e.DepartmentID = d.DepartmentID;
```
**Resultado:**
| Name | DepartmentName |
|------|----------------|
| John | HR             |
| Jane | IT             |
| Sam  | NULL           |
| NULL | Marketing      |

Os joins s√£o ferramentas poderosas para consultar dados de m√∫ltiplas tabelas, permitindo uma an√°lise e uma integra√ß√£o de dados mais robusta.

------------------------------------------------------

## UNION

A cl√°usula **UNION** √© usada para combinar os resultados de duas ou mais consultas **SELECT** em um √∫nico conjunto de resultados. Ela √© especialmente √∫til quando voc√™ deseja obter informa√ß√µes de v√°rias tabelas relacionadas, mantendo a clareza e legibilidade do c√≥digo.

### Sintaxe B√°sica
A sintaxe b√°sica da cl√°usula **UNION** √© a seguinte:
```sql
SELECT coluna1, coluna2, ... FROM tabela1
UNION [ALL]
SELECT coluna1, coluna2, ... FROM tabela2;
```

- O operador **UNION** combina os resultados de duas ou mais consultas.
- O modificador **ALL** (opcional) inclui todas as linhas nos resultados, incluindo duplicatas. Se n√£o for especificado, as linhas duplicadas ser√£o removidas.

### Exemplo Pr√°tico
Suponha que temos duas tabelas: "VendasOnline" e "VendasLojaF√≠sica". Queremos obter todas as vendas de ambos os canais. Podemos usar a cl√°usula **UNION** assim:
```sql
SELECT NumeroPedido, DataVenda FROM VendasOnline
UNION
SELECT NumeroPedido, DataVenda FROM VendasLojaF√≠sica;
```

Nesse exemplo, o **UNION** combina os resultados das duas tabelas, retornando um conjunto de resultados √∫nico com todas as vendas.

Lembre-se de que o **UNION** n√£o cria linhas individuais com base em colunas coletadas de duas tabelas; ele simplesmente concatena os resultados das consultas.

------------------------------------------------------

## GROUP BY

A cl√°usula **GROUP BY** √© usada para dividir o resultado de uma consulta em grupos de linhas, normalmente aplicando uma ou mais fun√ß√µes de agrega√ß√£o em cada grupo. Vamos explorar os detalhes:

1. **Sintaxe B√°sica**:
   - A sintaxe b√°sica da cl√°usula **GROUP BY** √©:
     ```sql
     SELECT coluna1, coluna2, ..., fun√ß√£o_agrega√ß√£o(coluna) AS nome_coluna
     FROM tabela
     GROUP BY coluna1, coluna2, ...;
     ```
   - Por exemplo, para calcular a soma dos sal√°rios por departamento:
     ```sql
     SELECT departamento, SUM(salario) AS total_salarios
     FROM funcionarios
     GROUP BY departamento;
     ```

2. **Fun√ß√µes de Agrega√ß√£o**:
   - As fun√ß√µes de agrega√ß√£o incluem **SUM**, **AVG**, **COUNT**, **MIN**, **MAX** etc.
   - Elas operam nos valores de uma coluna dentro de cada grupo.

3. **Observa√ß√µes Importantes**:
   - As colunas listadas no **GROUP BY** devem estar presentes na cl√°usula **SELECT** ou serem fun√ß√µes de agrega√ß√£o.
   - O **GROUP BY** n√£o pode ser usado sem fun√ß√µes de agrega√ß√£o.

As cl√°usulas **GROUP BY** s√£o essenciais para resumir dados e obter insights agregados.

------------------------------------------------------

## HAVING

A cl√°usula **HAVING** √© usada para filtrar os resultados de uma consulta ap√≥s a aplica√ß√£o da cl√°usula **GROUP BY**. Ela permite que voc√™ especifique condi√ß√µes para grupos agregados. Vamos explorar os detalhes:

1. **Uso da Cl√°usula HAVING**:
   - A cl√°usula **HAVING** √© aplicada ap√≥s o **GROUP BY** e permite filtrar grupos com base em fun√ß√µes agregadas (como **SUM**, **COUNT**, **AVG**, etc.).
   - Por exemplo, se quisermos encontrar os departamentos com uma m√©dia salarial superior a 5000, podemos fazer:
     ```sql
     SELECT departamento, AVG(salario) AS media_salarial
     FROM funcionarios
     GROUP BY departamento
     HAVING AVG(salario) > 5000;
     ```

2. **Diferen√ßa entre WHERE e HAVING**:
   - O **WHERE** filtra linhas antes do **GROUP BY**, enquanto o **HAVING** filtra grupos ap√≥s o **GROUP BY**.
   - O **WHERE** √© usado para condi√ß√µes individuais em linhas, e o **HAVING** √© usado para condi√ß√µes agregadas em grupos.

3. **Observa√ß√µes Importantes**:
   - O **HAVING** deve ser usado com fun√ß√µes agregadas (como **SUM**, **AVG**, etc.).
   - Ele n√£o pode ser usado sem o **GROUP BY**.

------------------------------------------------------

## VIEWS

As **views** (ou vis√µes) s√£o uma ferramenta poderosa no **SQL Server** e em outros sistemas de gerenciamento de banco de dados. Elas permitem criar consultas predefinidas que podem ser tratadas como tabelas virtuais. Vamos explorar os conceitos b√°sicos:

1. **O que √© uma View?**
   - Uma **view** √© uma consulta SQL armazenada no banco de dados como um objeto.
   - Ela representa uma tabela virtual que cont√©m os resultados de uma consulta.
   - As views podem simplificar consultas complexas, melhorar a seguran√ßa e facilitar o acesso aos dados.

2. **Vantagens das Views:**
   - **Seguran√ßa**: Voc√™ pode restringir o acesso direto √†s tabelas e permitir que os usu√°rios acessem apenas dados espec√≠ficos via views.
   - **Simplicidade**: Views podem ocultar a complexidade de joins e c√°lculos.
   - **Consist√™ncia**: L√≥gica complexa pode ser encapsulada em views para reutiliza√ß√£o.

3. **Exemplo de Cria√ß√£o de View:**
   - Suponha que temos uma tabela de produtos e queremos criar uma view que mostre o nome do produto, a marca e o pre√ßo:
     ```sql
     CREATE VIEW InformacoesProduto AS
     SELECT NomeProduto, Marca, Preco FROM Produtos;
     ```
   - Agora podemos consultar a view como se fosse uma tabela:
     ```sql
     SELECT * FROM InformacoesProduto;
     ```

4. **Gerenciando Views:**
   - **Criar**: Use `CREATE VIEW` para criar uma nova view.
   - **Modificar**: Use `ALTER VIEW` para modificar uma view existente.
   - **Excluir**: Use `DROP VIEW` para remover uma view.

As views s√£o √∫teis para simplificar consultas e melhorar a organiza√ß√£o dos dados.

------------------------------------------------------

## STORED PROCEDURES

As **stored procedures** s√£o um recurso essencial no **SQL Server** e em outros sistemas de gerenciamento de banco de dados. Elas permitem agrupar um ou mais comandos SQL em uma unidade l√≥gica, que pode ser reutilizada e executada como uma √∫nica entidade. Vamos explorar os conceitos b√°sicos:

1. **O que √© uma Stored Procedure?**
   - Uma **stored procedure** √© um conjunto de comandos SQL pr√©-compilados que podem ser armazenados no banco de dados.
   - Elas s√£o usadas para encapsular l√≥gica de neg√≥cios, opera√ß√µes repetitivas ou tarefas complexas.
   - As stored procedures podem aceitar par√¢metros de entrada e retornar resultados.

2. **Benef√≠cios das Stored Procedures:**
   - **Facilidade de Modifica√ß√£o:** Voc√™ pode alterar o c√≥digo dentro da stored procedure sem reiniciar ou redeployar a aplica√ß√£o.
   - **Redu√ß√£o de Tr√°fego de Rede:** Apenas o nome da stored procedure √© transmitido pela rede, em vez de todo o c√≥digo SQL.
   - **Reutiliza√ß√£o:** As stored procedures podem ser executadas por v√°rios usu√°rios ou aplicativos sem reescrever o c√≥digo.
   - **Seguran√ßa:** Elas reduzem a amea√ßa, pois evitam o acesso direto √†s tabelas.
   - **Desempenho:** A execu√ß√£o de uma stored procedure cria um plano de execu√ß√£o que pode ser reutilizado.

3. **Exemplo de Cria√ß√£o de Stored Procedure:**
   - Vamos criar uma stored procedure simples que junta duas tabelas e retorna o resultado:
     ```sql
     CREATE PROCEDURE ObterDescricaoProduto AS
     BEGIN
         SELECT P.ProductID, P.ProductName, PD.ProductDescription
         FROM Product P
         INNER JOIN ProductDescription PD ON P.ProductID = PD.ProductID;
     END;
     ```
   - Para executar a stored procedure, use:
     ```sql
     EXEC ObterDescricaoProduto;
     ```

4. **Modifica√ß√£o e Exclus√£o:**
   - Use `ALTER PROCEDURE` para modificar uma stored procedure existente.
   - Use `DROP PROCEDURE` para exclu√≠-la.

As stored procedures s√£o uma ferramenta poderosa para otimizar o acesso ao banco de dados.

------------------------------------------------------

## VARI√ÅVEIS

As **vari√°veis** s√£o elementos essenciais no **SQL Server** e em outros sistemas de gerenciamento de banco de dados. Elas permitem armazenar e manipular valores tempor√°rios durante a execu√ß√£o de consultas e procedimentos. Vamos explorar os conceitos b√°sicos:

1. **O que √© uma Vari√°vel?**
   - Uma vari√°vel √© um objeto que pode conter um √∫nico valor de um tipo espec√≠fico.
   - Elas s√£o usadas para armazenar dados tempor√°rios, como contadores, valores intermedi√°rios ou par√¢metros.

2. **Declara√ß√£o de Vari√°veis:**
   - A declara√ß√£o de uma vari√°vel √© feita usando a palavra-chave `DECLARE`.
   - Por exemplo, para criar uma vari√°vel chamada `@contador` do tipo inteiro com valor inicial zero:
     ```sql
     DECLARE @contador INT = 0;
     ```

3. **Escopo de Vari√°veis:**
   - O escopo de uma vari√°vel √© o intervalo de comandos SQL que pode fazer refer√™ncia a ela.
   - O escopo de uma vari√°vel dura desde o ponto em que ela √© declarada at√© o final do lote (batch) ou procedimento em que foi declarada.

4. **Exemplo Pr√°tico:**
   - Suponha que temos uma tabela de produtos e queremos calcular o pre√ßo m√©dio dos produtos:
     ```sql
     DECLARE @media_preco DECIMAL(10, 2);
     SELECT @media_preco = AVG(preco) FROM produtos;
     PRINT 'A m√©dia de pre√ßo dos produtos √©: ' + CAST(@media_preco AS VARCHAR);
     ```

As vari√°veis s√£o √∫teis para armazenar valores tempor√°rios e facilitar a escrita de consultas e procedimentos.
